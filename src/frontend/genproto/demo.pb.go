// Code generated by protoc-gen-go. DO NOT EDIT.
// source: demo.proto

/*
Package hipstershop is a generated protocol buffer package.

It is generated from these files:
	demo.proto

It has these top-level messages:
	Empty
	Product
	ListProductsResponse
	GetProductRequest
	SearchProductsRequest
	SearchProductsResponse
	Money
	GetSupportedCurrenciesResponse
	CurrencyConversionRequest
	AdRequest
	AdResponse
	Ad
*/
package hipstershop

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Product struct {
	Id          string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	Picture     string `protobuf:"bytes,4,opt,name=picture" json:"picture,omitempty"`
	PriceUsd    *Money `protobuf:"bytes,5,opt,name=price_usd,json=priceUsd" json:"price_usd,omitempty"`
	// Categories such as "vintage" or "gardening" that can be used to look up
	// other related products.
	Categories []string `protobuf:"bytes,6,rep,name=categories" json:"categories,omitempty"`
}

func (m *Product) Reset()                    { *m = Product{} }
func (m *Product) String() string            { return proto.CompactTextString(m) }
func (*Product) ProtoMessage()               {}
func (*Product) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Product) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Product) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Product) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Product) GetPicture() string {
	if m != nil {
		return m.Picture
	}
	return ""
}

func (m *Product) GetPriceUsd() *Money {
	if m != nil {
		return m.PriceUsd
	}
	return nil
}

func (m *Product) GetCategories() []string {
	if m != nil {
		return m.Categories
	}
	return nil
}

type ListProductsResponse struct {
	Products []*Product `protobuf:"bytes,1,rep,name=products" json:"products,omitempty"`
}

func (m *ListProductsResponse) Reset()                    { *m = ListProductsResponse{} }
func (m *ListProductsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListProductsResponse) ProtoMessage()               {}
func (*ListProductsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ListProductsResponse) GetProducts() []*Product {
	if m != nil {
		return m.Products
	}
	return nil
}

type GetProductRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *GetProductRequest) Reset()                    { *m = GetProductRequest{} }
func (m *GetProductRequest) String() string            { return proto.CompactTextString(m) }
func (*GetProductRequest) ProtoMessage()               {}
func (*GetProductRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *GetProductRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type SearchProductsRequest struct {
	Query string `protobuf:"bytes,1,opt,name=query" json:"query,omitempty"`
}

func (m *SearchProductsRequest) Reset()                    { *m = SearchProductsRequest{} }
func (m *SearchProductsRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchProductsRequest) ProtoMessage()               {}
func (*SearchProductsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SearchProductsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

type SearchProductsResponse struct {
	Results []*Product `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *SearchProductsResponse) Reset()                    { *m = SearchProductsResponse{} }
func (m *SearchProductsResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchProductsResponse) ProtoMessage()               {}
func (*SearchProductsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SearchProductsResponse) GetResults() []*Product {
	if m != nil {
		return m.Results
	}
	return nil
}

// Represents an amount of money with its currency type.
type Money struct {
	// The 3-letter currency code defined in ISO 4217.
	CurrencyCode string `protobuf:"bytes,1,opt,name=currency_code,json=currencyCode" json:"currency_code,omitempty"`
	// The whole units of the amount.
	// For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units int64 `protobuf:"varint,2,opt,name=units" json:"units,omitempty"`
	// Number of nano (10^-9) units of the amount.
	// The value must be between -999,999,999 and +999,999,999 inclusive.
	// If `units` is positive, `nanos` must be positive or zero.
	// If `units` is zero, `nanos` can be positive, zero, or negative.
	// If `units` is negative, `nanos` must be negative or zero.
	// For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos int32 `protobuf:"varint,3,opt,name=nanos" json:"nanos,omitempty"`
}

func (m *Money) Reset()                    { *m = Money{} }
func (m *Money) String() string            { return proto.CompactTextString(m) }
func (*Money) ProtoMessage()               {}
func (*Money) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Money) GetCurrencyCode() string {
	if m != nil {
		return m.CurrencyCode
	}
	return ""
}

func (m *Money) GetUnits() int64 {
	if m != nil {
		return m.Units
	}
	return 0
}

func (m *Money) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

type GetSupportedCurrenciesResponse struct {
	// The 3-letter currency code defined in ISO 4217.
	CurrencyCodes []string `protobuf:"bytes,1,rep,name=currency_codes,json=currencyCodes" json:"currency_codes,omitempty"`
}

func (m *GetSupportedCurrenciesResponse) Reset()                    { *m = GetSupportedCurrenciesResponse{} }
func (m *GetSupportedCurrenciesResponse) String() string            { return proto.CompactTextString(m) }
func (*GetSupportedCurrenciesResponse) ProtoMessage()               {}
func (*GetSupportedCurrenciesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetSupportedCurrenciesResponse) GetCurrencyCodes() []string {
	if m != nil {
		return m.CurrencyCodes
	}
	return nil
}

type CurrencyConversionRequest struct {
	From *Money `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	// The 3-letter currency code defined in ISO 4217.
	ToCode string `protobuf:"bytes,2,opt,name=to_code,json=toCode" json:"to_code,omitempty"`
}

func (m *CurrencyConversionRequest) Reset()                    { *m = CurrencyConversionRequest{} }
func (m *CurrencyConversionRequest) String() string            { return proto.CompactTextString(m) }
func (*CurrencyConversionRequest) ProtoMessage()               {}
func (*CurrencyConversionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CurrencyConversionRequest) GetFrom() *Money {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *CurrencyConversionRequest) GetToCode() string {
	if m != nil {
		return m.ToCode
	}
	return ""
}

type AdRequest struct {
	// List of important key words from the current page describing the context.
	ContextKeys []string `protobuf:"bytes,1,rep,name=context_keys,json=contextKeys" json:"context_keys,omitempty"`
}

func (m *AdRequest) Reset()                    { *m = AdRequest{} }
func (m *AdRequest) String() string            { return proto.CompactTextString(m) }
func (*AdRequest) ProtoMessage()               {}
func (*AdRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *AdRequest) GetContextKeys() []string {
	if m != nil {
		return m.ContextKeys
	}
	return nil
}

type AdResponse struct {
	Ads []*Ad `protobuf:"bytes,1,rep,name=ads" json:"ads,omitempty"`
}

func (m *AdResponse) Reset()                    { *m = AdResponse{} }
func (m *AdResponse) String() string            { return proto.CompactTextString(m) }
func (*AdResponse) ProtoMessage()               {}
func (*AdResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *AdResponse) GetAds() []*Ad {
	if m != nil {
		return m.Ads
	}
	return nil
}

type Ad struct {
	// Id of a random product.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// short link text to display in the Ad link.
	Text string `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
}

func (m *Ad) Reset()                    { *m = Ad{} }
func (m *Ad) String() string            { return proto.CompactTextString(m) }
func (*Ad) ProtoMessage()               {}
func (*Ad) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Ad) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Ad) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func init() {
	proto.RegisterType((*Empty)(nil), "hipstershop.Empty")
	proto.RegisterType((*Product)(nil), "hipstershop.Product")
	proto.RegisterType((*ListProductsResponse)(nil), "hipstershop.ListProductsResponse")
	proto.RegisterType((*GetProductRequest)(nil), "hipstershop.GetProductRequest")
	proto.RegisterType((*SearchProductsRequest)(nil), "hipstershop.SearchProductsRequest")
	proto.RegisterType((*SearchProductsResponse)(nil), "hipstershop.SearchProductsResponse")
	proto.RegisterType((*Money)(nil), "hipstershop.Money")
	proto.RegisterType((*GetSupportedCurrenciesResponse)(nil), "hipstershop.GetSupportedCurrenciesResponse")
	proto.RegisterType((*CurrencyConversionRequest)(nil), "hipstershop.CurrencyConversionRequest")
	proto.RegisterType((*AdRequest)(nil), "hipstershop.AdRequest")
	proto.RegisterType((*AdResponse)(nil), "hipstershop.AdResponse")
	proto.RegisterType((*Ad)(nil), "hipstershop.Ad")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ProductCatalogService service

type ProductCatalogServiceClient interface {
	ListProducts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListProductsResponse, error)
	GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*Product, error)
	SearchProducts(ctx context.Context, in *SearchProductsRequest, opts ...grpc.CallOption) (*SearchProductsResponse, error)
}

type productCatalogServiceClient struct {
	cc *grpc.ClientConn
}

func NewProductCatalogServiceClient(cc *grpc.ClientConn) ProductCatalogServiceClient {
	return &productCatalogServiceClient{cc}
}

func (c *productCatalogServiceClient) ListProducts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListProductsResponse, error) {
	out := new(ListProductsResponse)
	err := grpc.Invoke(ctx, "/hipstershop.ProductCatalogService/ListProducts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCatalogServiceClient) GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*Product, error) {
	out := new(Product)
	err := grpc.Invoke(ctx, "/hipstershop.ProductCatalogService/GetProduct", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCatalogServiceClient) SearchProducts(ctx context.Context, in *SearchProductsRequest, opts ...grpc.CallOption) (*SearchProductsResponse, error) {
	out := new(SearchProductsResponse)
	err := grpc.Invoke(ctx, "/hipstershop.ProductCatalogService/SearchProducts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ProductCatalogService service

type ProductCatalogServiceServer interface {
	ListProducts(context.Context, *Empty) (*ListProductsResponse, error)
	GetProduct(context.Context, *GetProductRequest) (*Product, error)
	SearchProducts(context.Context, *SearchProductsRequest) (*SearchProductsResponse, error)
}

func RegisterProductCatalogServiceServer(s *grpc.Server, srv ProductCatalogServiceServer) {
	s.RegisterService(&_ProductCatalogService_serviceDesc, srv)
}

func _ProductCatalogService_ListProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceServer).ListProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hipstershop.ProductCatalogService/ListProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceServer).ListProducts(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCatalogService_GetProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceServer).GetProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hipstershop.ProductCatalogService/GetProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceServer).GetProduct(ctx, req.(*GetProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCatalogService_SearchProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceServer).SearchProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hipstershop.ProductCatalogService/SearchProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceServer).SearchProducts(ctx, req.(*SearchProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProductCatalogService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hipstershop.ProductCatalogService",
	HandlerType: (*ProductCatalogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListProducts",
			Handler:    _ProductCatalogService_ListProducts_Handler,
		},
		{
			MethodName: "GetProduct",
			Handler:    _ProductCatalogService_GetProduct_Handler,
		},
		{
			MethodName: "SearchProducts",
			Handler:    _ProductCatalogService_SearchProducts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "demo.proto",
}

// Client API for CurrencyService service

type CurrencyServiceClient interface {
	GetSupportedCurrencies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSupportedCurrenciesResponse, error)
	Convert(ctx context.Context, in *CurrencyConversionRequest, opts ...grpc.CallOption) (*Money, error)
}

type currencyServiceClient struct {
	cc *grpc.ClientConn
}

func NewCurrencyServiceClient(cc *grpc.ClientConn) CurrencyServiceClient {
	return &currencyServiceClient{cc}
}

func (c *currencyServiceClient) GetSupportedCurrencies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSupportedCurrenciesResponse, error) {
	out := new(GetSupportedCurrenciesResponse)
	err := grpc.Invoke(ctx, "/hipstershop.CurrencyService/GetSupportedCurrencies", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *currencyServiceClient) Convert(ctx context.Context, in *CurrencyConversionRequest, opts ...grpc.CallOption) (*Money, error) {
	out := new(Money)
	err := grpc.Invoke(ctx, "/hipstershop.CurrencyService/Convert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CurrencyService service

type CurrencyServiceServer interface {
	GetSupportedCurrencies(context.Context, *Empty) (*GetSupportedCurrenciesResponse, error)
	Convert(context.Context, *CurrencyConversionRequest) (*Money, error)
}

func RegisterCurrencyServiceServer(s *grpc.Server, srv CurrencyServiceServer) {
	s.RegisterService(&_CurrencyService_serviceDesc, srv)
}

func _CurrencyService_GetSupportedCurrencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyServiceServer).GetSupportedCurrencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hipstershop.CurrencyService/GetSupportedCurrencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyServiceServer).GetSupportedCurrencies(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CurrencyService_Convert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CurrencyConversionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyServiceServer).Convert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hipstershop.CurrencyService/Convert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyServiceServer).Convert(ctx, req.(*CurrencyConversionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CurrencyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hipstershop.CurrencyService",
	HandlerType: (*CurrencyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSupportedCurrencies",
			Handler:    _CurrencyService_GetSupportedCurrencies_Handler,
		},
		{
			MethodName: "Convert",
			Handler:    _CurrencyService_Convert_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "demo.proto",
}

// Client API for AdServiceV2 service

type AdServiceV2Client interface {
	GetAds(ctx context.Context, in *AdRequest, opts ...grpc.CallOption) (*AdResponse, error)
}

type adServiceV2Client struct {
	cc *grpc.ClientConn
}

func NewAdServiceV2Client(cc *grpc.ClientConn) AdServiceV2Client {
	return &adServiceV2Client{cc}
}

func (c *adServiceV2Client) GetAds(ctx context.Context, in *AdRequest, opts ...grpc.CallOption) (*AdResponse, error) {
	out := new(AdResponse)
	err := grpc.Invoke(ctx, "/hipstershop.AdServiceV2/GetAds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AdServiceV2 service

type AdServiceV2Server interface {
	GetAds(context.Context, *AdRequest) (*AdResponse, error)
}

func RegisterAdServiceV2Server(s *grpc.Server, srv AdServiceV2Server) {
	s.RegisterService(&_AdServiceV2_serviceDesc, srv)
}

func _AdServiceV2_GetAds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdServiceV2Server).GetAds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hipstershop.AdServiceV2/GetAds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdServiceV2Server).GetAds(ctx, req.(*AdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AdServiceV2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hipstershop.AdServiceV2",
	HandlerType: (*AdServiceV2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAds",
			Handler:    _AdServiceV2_GetAds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "demo.proto",
}

func init() { proto.RegisterFile("demo.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 609 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0x5b, 0x6b, 0xdb, 0x4c,
	0x10, 0xb5, 0xec, 0xd8, 0x8a, 0x47, 0xb9, 0xf0, 0x2d, 0xb9, 0xe8, 0xf3, 0x43, 0x70, 0x36, 0x34,
	0x18, 0x4a, 0x9d, 0xa2, 0x3e, 0xf6, 0xc9, 0xb8, 0x45, 0xa1, 0x17, 0x28, 0x0a, 0x2d, 0x85, 0x14,
	0x82, 0xaa, 0x9d, 0x26, 0x4b, 0x63, 0xad, 0xb2, 0xbb, 0x0a, 0xd5, 0x73, 0x7f, 0x54, 0xa1, 0xbf,
	0xae, 0x68, 0xa5, 0x4d, 0xac, 0x58, 0x4d, 0xdf, 0xb4, 0x67, 0xce, 0xce, 0x9c, 0x99, 0x39, 0x2b,
	0x00, 0x86, 0x0b, 0x31, 0xcd, 0xa4, 0xd0, 0x82, 0x78, 0x57, 0x3c, 0x53, 0x1a, 0xa5, 0xba, 0x12,
	0x19, 0x75, 0xa1, 0xff, 0x7a, 0x91, 0xe9, 0x82, 0xfe, 0x76, 0xc0, 0xfd, 0x20, 0x05, 0xcb, 0x13,
	0x4d, 0xb6, 0xa0, 0xcb, 0x99, 0xef, 0x8c, 0x9d, 0xc9, 0x30, 0xea, 0x72, 0x46, 0x08, 0xac, 0xa5,
	0xf1, 0x02, 0xfd, 0xae, 0x41, 0xcc, 0x37, 0x19, 0x83, 0xc7, 0x50, 0x25, 0x92, 0x67, 0x9a, 0x8b,
	0xd4, 0xef, 0x99, 0xd0, 0x32, 0x44, 0x7c, 0x70, 0x33, 0x9e, 0xe8, 0x5c, 0xa2, 0xbf, 0x66, 0xa2,
	0xf6, 0x48, 0x4e, 0x60, 0x98, 0x49, 0x9e, 0xe0, 0x45, 0xae, 0x98, 0xdf, 0x1f, 0x3b, 0x13, 0x2f,
	0x20, 0xd3, 0x25, 0x55, 0xd3, 0xf7, 0x22, 0xc5, 0x22, 0x5a, 0x37, 0xa4, 0x8f, 0x8a, 0x91, 0x03,
	0x80, 0x24, 0xd6, 0x78, 0x29, 0x24, 0x47, 0xe5, 0x0f, 0xc6, 0xbd, 0xc9, 0x30, 0x5a, 0x42, 0xe8,
	0x29, 0xec, 0xbc, 0xe3, 0x4a, 0xd7, 0xfa, 0x55, 0x84, 0x2a, 0x13, 0xa9, 0x42, 0xf2, 0x1c, 0xd6,
	0xb3, 0x1a, 0xf3, 0x9d, 0x71, 0x6f, 0xe2, 0x05, 0x3b, 0x8d, 0x3a, 0xf5, 0x85, 0xe8, 0x8e, 0x45,
	0x8f, 0xe0, 0xbf, 0x10, 0x6d, 0xa2, 0x08, 0x6f, 0x72, 0x54, 0x2b, 0xf3, 0xa0, 0xcf, 0x60, 0xf7,
	0x0c, 0x63, 0x99, 0x5c, 0xdd, 0x17, 0xac, 0x88, 0x3b, 0xd0, 0xbf, 0xc9, 0x51, 0x16, 0x35, 0xb7,
	0x3a, 0xd0, 0x53, 0xd8, 0x7b, 0x48, 0xaf, 0xf5, 0x4d, 0xc1, 0x95, 0xa8, 0xf2, 0xeb, 0x7f, 0xc8,
	0xb3, 0x24, 0xfa, 0x19, 0xfa, 0x66, 0x34, 0xe4, 0x08, 0x36, 0x93, 0x5c, 0x4a, 0x4c, 0x93, 0xe2,
	0x22, 0x11, 0x0c, 0xeb, 0x82, 0x1b, 0x16, 0x9c, 0x0b, 0x86, 0xa5, 0x9a, 0x3c, 0xe5, 0x5a, 0x99,
	0xbd, 0xf5, 0xa2, 0xea, 0x50, 0xa2, 0x69, 0x9c, 0x0a, 0x65, 0x56, 0xd6, 0x8f, 0xaa, 0x03, 0x0d,
	0xe1, 0x20, 0x44, 0x7d, 0x96, 0x67, 0x99, 0x90, 0x1a, 0xd9, 0xbc, 0xca, 0xc3, 0xf1, 0x5e, 0xeb,
	0x13, 0xd8, 0x6a, 0x94, 0xac, 0x24, 0x0f, 0xa3, 0xcd, 0xe5, 0x9a, 0x8a, 0x7e, 0x81, 0xff, 0xe7,
	0x77, 0x40, 0x7a, 0x8b, 0x52, 0x71, 0x91, 0xda, 0xf9, 0x1c, 0xc3, 0xda, 0x37, 0x29, 0x16, 0x46,
	0x6d, 0xfb, 0xce, 0x4d, 0x9c, 0xec, 0x83, 0xab, 0x45, 0xd5, 0x58, 0xe5, 0xb9, 0x81, 0x16, 0x65,
	0x7a, 0x3a, 0x85, 0xe1, 0x8c, 0xd9, 0x6c, 0x87, 0xb0, 0x91, 0x88, 0x54, 0xe3, 0x0f, 0x7d, 0xf1,
	0x1d, 0x0b, 0xab, 0xc7, 0xab, 0xb1, 0xb7, 0x58, 0x28, 0x7a, 0x02, 0x50, 0xf2, 0xeb, 0x16, 0x0e,
	0xa1, 0x17, 0x33, 0x3b, 0xea, 0xed, 0x46, 0xf5, 0x19, 0x8b, 0xca, 0x18, 0x9d, 0x40, 0x77, 0xc6,
	0xda, 0x1e, 0x40, 0x99, 0xd2, 0x3e, 0x80, 0xf2, 0x3b, 0xf8, 0xd9, 0x85, 0xdd, 0x7a, 0x41, 0xf3,
	0x58, 0xc7, 0xd7, 0xe2, 0xf2, 0x0c, 0xe5, 0x2d, 0x4f, 0x90, 0x84, 0xb0, 0xb1, 0xec, 0x46, 0xd2,
	0xec, 0xd3, 0x3c, 0xb7, 0xd1, 0x61, 0x03, 0x6b, 0x33, 0x2f, 0xed, 0x90, 0x57, 0x00, 0xf7, 0x66,
	0x24, 0x07, 0x8d, 0x2b, 0x2b, 0x2e, 0x1d, 0xb5, 0x7a, 0x87, 0x76, 0xc8, 0x39, 0x6c, 0x35, 0xed,
	0x47, 0x68, 0x83, 0xd9, 0x6a, 0xe5, 0xd1, 0xd1, 0xa3, 0x1c, 0x2b, 0x31, 0xf8, 0xe5, 0xc0, 0xb6,
	0xdd, 0xb7, 0xed, 0xff, 0x1c, 0xf6, 0xda, 0xbd, 0xd4, 0x3a, 0x89, 0xa7, 0x0f, 0xdb, 0x7a, 0xc4,
	0x84, 0xb4, 0x43, 0x42, 0x70, 0x2b, 0x5f, 0x69, 0x72, 0xdc, 0xb8, 0xf9, 0x57, 0xd7, 0x8d, 0x5a,
	0x7c, 0x46, 0x3b, 0xc1, 0x1b, 0xf0, 0x66, 0xac, 0x96, 0xfc, 0x29, 0x20, 0x2f, 0x61, 0x10, 0xa2,
	0x9e, 0x31, 0x45, 0xf6, 0x1e, 0x1a, 0xa3, 0x4e, 0xb3, 0xbf, 0x82, 0x5b, 0x51, 0x5f, 0x07, 0xe6,
	0xcf, 0xfa, 0xe2, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x70, 0xd6, 0x20, 0x68, 0x67, 0x05, 0x00,
	0x00,
}
