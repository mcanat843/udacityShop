// Code generated by protoc-gen-go. DO NOT EDIT.
// source: demo.proto

/*
Package hipstershop is a generated protocol buffer package.

It is generated from these files:
	demo.proto

It has these top-level messages:
	Empty
	Product
	ListProductsResponse
	GetProductRequest
	SearchProductsRequest
	SearchProductsResponse
	Money
	GetSupportedCurrenciesResponse
	CurrencyConversionRequest
	AdRequest
	AdResponse
	Ad
*/
package hipstershop

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Product struct {
	Id          string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	Picture     string `protobuf:"bytes,4,opt,name=picture" json:"picture,omitempty"`
	PriceUsd    *Money `protobuf:"bytes,5,opt,name=price_usd,json=priceUsd" json:"price_usd,omitempty"`
	// Categories such as "vintage" or "gardening" that can be used to look up
	// other related products.
	Categories []string `protobuf:"bytes,6,rep,name=categories" json:"categories,omitempty"`
}

func (m *Product) Reset()                    { *m = Product{} }
func (m *Product) String() string            { return proto.CompactTextString(m) }
func (*Product) ProtoMessage()               {}
func (*Product) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Product) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Product) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Product) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Product) GetPicture() string {
	if m != nil {
		return m.Picture
	}
	return ""
}

func (m *Product) GetPriceUsd() *Money {
	if m != nil {
		return m.PriceUsd
	}
	return nil
}

func (m *Product) GetCategories() []string {
	if m != nil {
		return m.Categories
	}
	return nil
}

type ListProductsResponse struct {
	Products []*Product `protobuf:"bytes,1,rep,name=products" json:"products,omitempty"`
}

func (m *ListProductsResponse) Reset()                    { *m = ListProductsResponse{} }
func (m *ListProductsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListProductsResponse) ProtoMessage()               {}
func (*ListProductsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ListProductsResponse) GetProducts() []*Product {
	if m != nil {
		return m.Products
	}
	return nil
}

type GetProductRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *GetProductRequest) Reset()                    { *m = GetProductRequest{} }
func (m *GetProductRequest) String() string            { return proto.CompactTextString(m) }
func (*GetProductRequest) ProtoMessage()               {}
func (*GetProductRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *GetProductRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type SearchProductsRequest struct {
	Query string `protobuf:"bytes,1,opt,name=query" json:"query,omitempty"`
}

func (m *SearchProductsRequest) Reset()                    { *m = SearchProductsRequest{} }
func (m *SearchProductsRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchProductsRequest) ProtoMessage()               {}
func (*SearchProductsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SearchProductsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

type SearchProductsResponse struct {
	Results []*Product `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *SearchProductsResponse) Reset()                    { *m = SearchProductsResponse{} }
func (m *SearchProductsResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchProductsResponse) ProtoMessage()               {}
func (*SearchProductsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SearchProductsResponse) GetResults() []*Product {
	if m != nil {
		return m.Results
	}
	return nil
}

// Represents an amount of money with its currency type.
type Money struct {
	// The 3-letter currency code defined in ISO 4217.
	CurrencyCode string `protobuf:"bytes,1,opt,name=currency_code,json=currencyCode" json:"currency_code,omitempty"`
	// The whole units of the amount.
	// For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units int64 `protobuf:"varint,2,opt,name=units" json:"units,omitempty"`
	// Number of nano (10^-9) units of the amount.
	// The value must be between -999,999,999 and +999,999,999 inclusive.
	// If `units` is positive, `nanos` must be positive or zero.
	// If `units` is zero, `nanos` can be positive, zero, or negative.
	// If `units` is negative, `nanos` must be negative or zero.
	// For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos int32 `protobuf:"varint,3,opt,name=nanos" json:"nanos,omitempty"`
}

func (m *Money) Reset()                    { *m = Money{} }
func (m *Money) String() string            { return proto.CompactTextString(m) }
func (*Money) ProtoMessage()               {}
func (*Money) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Money) GetCurrencyCode() string {
	if m != nil {
		return m.CurrencyCode
	}
	return ""
}

func (m *Money) GetUnits() int64 {
	if m != nil {
		return m.Units
	}
	return 0
}

func (m *Money) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

type GetSupportedCurrenciesResponse struct {
	// The 3-letter currency code defined in ISO 4217.
	CurrencyCodes []string `protobuf:"bytes,1,rep,name=currency_codes,json=currencyCodes" json:"currency_codes,omitempty"`
}

func (m *GetSupportedCurrenciesResponse) Reset()                    { *m = GetSupportedCurrenciesResponse{} }
func (m *GetSupportedCurrenciesResponse) String() string            { return proto.CompactTextString(m) }
func (*GetSupportedCurrenciesResponse) ProtoMessage()               {}
func (*GetSupportedCurrenciesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetSupportedCurrenciesResponse) GetCurrencyCodes() []string {
	if m != nil {
		return m.CurrencyCodes
	}
	return nil
}

type CurrencyConversionRequest struct {
	From *Money `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	// The 3-letter currency code defined in ISO 4217.
	ToCode string `protobuf:"bytes,2,opt,name=to_code,json=toCode" json:"to_code,omitempty"`
}

func (m *CurrencyConversionRequest) Reset()                    { *m = CurrencyConversionRequest{} }
func (m *CurrencyConversionRequest) String() string            { return proto.CompactTextString(m) }
func (*CurrencyConversionRequest) ProtoMessage()               {}
func (*CurrencyConversionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CurrencyConversionRequest) GetFrom() *Money {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *CurrencyConversionRequest) GetToCode() string {
	if m != nil {
		return m.ToCode
	}
	return ""
}

type AdRequest struct {
	// List of important key words from the current page describing the context.
	ContextKeys []string `protobuf:"bytes,1,rep,name=context_keys,json=contextKeys" json:"context_keys,omitempty"`
}

func (m *AdRequest) Reset()                    { *m = AdRequest{} }
func (m *AdRequest) String() string            { return proto.CompactTextString(m) }
func (*AdRequest) ProtoMessage()               {}
func (*AdRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *AdRequest) GetContextKeys() []string {
	if m != nil {
		return m.ContextKeys
	}
	return nil
}

type AdResponse struct {
	Ads []*Ad `protobuf:"bytes,1,rep,name=ads" json:"ads,omitempty"`
}

func (m *AdResponse) Reset()                    { *m = AdResponse{} }
func (m *AdResponse) String() string            { return proto.CompactTextString(m) }
func (*AdResponse) ProtoMessage()               {}
func (*AdResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *AdResponse) GetAds() []*Ad {
	if m != nil {
		return m.Ads
	}
	return nil
}

type Ad struct {
	// url to redirect to when an ad is clicked.
	RedirectUrl string `protobuf:"bytes,1,opt,name=redirect_url,json=redirectUrl" json:"redirect_url,omitempty"`
	// short advertisement text to display.
	Text string `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
}

func (m *Ad) Reset()                    { *m = Ad{} }
func (m *Ad) String() string            { return proto.CompactTextString(m) }
func (*Ad) ProtoMessage()               {}
func (*Ad) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Ad) GetRedirectUrl() string {
	if m != nil {
		return m.RedirectUrl
	}
	return ""
}

func (m *Ad) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func init() {
	proto.RegisterType((*Empty)(nil), "hipstershop.Empty")
	proto.RegisterType((*Product)(nil), "hipstershop.Product")
	proto.RegisterType((*ListProductsResponse)(nil), "hipstershop.ListProductsResponse")
	proto.RegisterType((*GetProductRequest)(nil), "hipstershop.GetProductRequest")
	proto.RegisterType((*SearchProductsRequest)(nil), "hipstershop.SearchProductsRequest")
	proto.RegisterType((*SearchProductsResponse)(nil), "hipstershop.SearchProductsResponse")
	proto.RegisterType((*Money)(nil), "hipstershop.Money")
	proto.RegisterType((*GetSupportedCurrenciesResponse)(nil), "hipstershop.GetSupportedCurrenciesResponse")
	proto.RegisterType((*CurrencyConversionRequest)(nil), "hipstershop.CurrencyConversionRequest")
	proto.RegisterType((*AdRequest)(nil), "hipstershop.AdRequest")
	proto.RegisterType((*AdResponse)(nil), "hipstershop.AdResponse")
	proto.RegisterType((*Ad)(nil), "hipstershop.Ad")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ProductCatalogService service

type ProductCatalogServiceClient interface {
	ListProducts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListProductsResponse, error)
	GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*Product, error)
	SearchProducts(ctx context.Context, in *SearchProductsRequest, opts ...grpc.CallOption) (*SearchProductsResponse, error)
}

type productCatalogServiceClient struct {
	cc *grpc.ClientConn
}

func NewProductCatalogServiceClient(cc *grpc.ClientConn) ProductCatalogServiceClient {
	return &productCatalogServiceClient{cc}
}

func (c *productCatalogServiceClient) ListProducts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListProductsResponse, error) {
	out := new(ListProductsResponse)
	err := grpc.Invoke(ctx, "/hipstershop.ProductCatalogService/ListProducts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCatalogServiceClient) GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*Product, error) {
	out := new(Product)
	err := grpc.Invoke(ctx, "/hipstershop.ProductCatalogService/GetProduct", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCatalogServiceClient) SearchProducts(ctx context.Context, in *SearchProductsRequest, opts ...grpc.CallOption) (*SearchProductsResponse, error) {
	out := new(SearchProductsResponse)
	err := grpc.Invoke(ctx, "/hipstershop.ProductCatalogService/SearchProducts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ProductCatalogService service

type ProductCatalogServiceServer interface {
	ListProducts(context.Context, *Empty) (*ListProductsResponse, error)
	GetProduct(context.Context, *GetProductRequest) (*Product, error)
	SearchProducts(context.Context, *SearchProductsRequest) (*SearchProductsResponse, error)
}

func RegisterProductCatalogServiceServer(s *grpc.Server, srv ProductCatalogServiceServer) {
	s.RegisterService(&_ProductCatalogService_serviceDesc, srv)
}

func _ProductCatalogService_ListProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceServer).ListProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hipstershop.ProductCatalogService/ListProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceServer).ListProducts(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCatalogService_GetProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceServer).GetProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hipstershop.ProductCatalogService/GetProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceServer).GetProduct(ctx, req.(*GetProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCatalogService_SearchProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceServer).SearchProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hipstershop.ProductCatalogService/SearchProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceServer).SearchProducts(ctx, req.(*SearchProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProductCatalogService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hipstershop.ProductCatalogService",
	HandlerType: (*ProductCatalogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListProducts",
			Handler:    _ProductCatalogService_ListProducts_Handler,
		},
		{
			MethodName: "GetProduct",
			Handler:    _ProductCatalogService_GetProduct_Handler,
		},
		{
			MethodName: "SearchProducts",
			Handler:    _ProductCatalogService_SearchProducts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "demo.proto",
}

// Client API for CurrencyService service

type CurrencyServiceClient interface {
	GetSupportedCurrencies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSupportedCurrenciesResponse, error)
	Convert(ctx context.Context, in *CurrencyConversionRequest, opts ...grpc.CallOption) (*Money, error)
}

type currencyServiceClient struct {
	cc *grpc.ClientConn
}

func NewCurrencyServiceClient(cc *grpc.ClientConn) CurrencyServiceClient {
	return &currencyServiceClient{cc}
}

func (c *currencyServiceClient) GetSupportedCurrencies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetSupportedCurrenciesResponse, error) {
	out := new(GetSupportedCurrenciesResponse)
	err := grpc.Invoke(ctx, "/hipstershop.CurrencyService/GetSupportedCurrencies", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *currencyServiceClient) Convert(ctx context.Context, in *CurrencyConversionRequest, opts ...grpc.CallOption) (*Money, error) {
	out := new(Money)
	err := grpc.Invoke(ctx, "/hipstershop.CurrencyService/Convert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CurrencyService service

type CurrencyServiceServer interface {
	GetSupportedCurrencies(context.Context, *Empty) (*GetSupportedCurrenciesResponse, error)
	Convert(context.Context, *CurrencyConversionRequest) (*Money, error)
}

func RegisterCurrencyServiceServer(s *grpc.Server, srv CurrencyServiceServer) {
	s.RegisterService(&_CurrencyService_serviceDesc, srv)
}

func _CurrencyService_GetSupportedCurrencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyServiceServer).GetSupportedCurrencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hipstershop.CurrencyService/GetSupportedCurrencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyServiceServer).GetSupportedCurrencies(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CurrencyService_Convert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CurrencyConversionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyServiceServer).Convert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hipstershop.CurrencyService/Convert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyServiceServer).Convert(ctx, req.(*CurrencyConversionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CurrencyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hipstershop.CurrencyService",
	HandlerType: (*CurrencyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSupportedCurrencies",
			Handler:    _CurrencyService_GetSupportedCurrencies_Handler,
		},
		{
			MethodName: "Convert",
			Handler:    _CurrencyService_Convert_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "demo.proto",
}

// Client API for AdService service

type AdServiceClient interface {
	GetAds(ctx context.Context, in *AdRequest, opts ...grpc.CallOption) (*AdResponse, error)
}

type adServiceClient struct {
	cc *grpc.ClientConn
}

func NewAdServiceClient(cc *grpc.ClientConn) AdServiceClient {
	return &adServiceClient{cc}
}

func (c *adServiceClient) GetAds(ctx context.Context, in *AdRequest, opts ...grpc.CallOption) (*AdResponse, error) {
	out := new(AdResponse)
	err := grpc.Invoke(ctx, "/hipstershop.AdService/GetAds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AdService service

type AdServiceServer interface {
	GetAds(context.Context, *AdRequest) (*AdResponse, error)
}

func RegisterAdServiceServer(s *grpc.Server, srv AdServiceServer) {
	s.RegisterService(&_AdService_serviceDesc, srv)
}

func _AdService_GetAds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdServiceServer).GetAds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hipstershop.AdService/GetAds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdServiceServer).GetAds(ctx, req.(*AdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AdService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hipstershop.AdService",
	HandlerType: (*AdServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAds",
			Handler:    _AdService_GetAds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "demo.proto",
}

func init() { proto.RegisterFile("demo.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 621 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0x5b, 0x6b, 0xdb, 0x4c,
	0x10, 0xf5, 0x25, 0xb6, 0xe3, 0x51, 0x2e, 0x7c, 0x4b, 0x2e, 0xfa, 0xfc, 0x10, 0x9c, 0x0d, 0x0d,
	0x86, 0x52, 0xa7, 0xb8, 0x8f, 0x79, 0x32, 0x6e, 0x51, 0xa0, 0x2d, 0x14, 0x85, 0x40, 0x21, 0x05,
	0xa3, 0xee, 0x4e, 0x93, 0xa5, 0xb6, 0x56, 0xd9, 0x5d, 0x85, 0xea, 0xb9, 0x3f, 0xaa, 0xd0, 0x5f,
	0x57, 0xb4, 0xd2, 0x26, 0x56, 0xac, 0xa6, 0x6f, 0xda, 0x33, 0x67, 0x67, 0xce, 0xcc, 0x9c, 0x15,
	0x00, 0xc7, 0xa5, 0x1c, 0x27, 0x4a, 0x1a, 0x49, 0xbc, 0x5b, 0x91, 0x68, 0x83, 0x4a, 0xdf, 0xca,
	0x84, 0xf6, 0xa0, 0xf3, 0x6e, 0x99, 0x98, 0x8c, 0xfe, 0x6e, 0x42, 0xef, 0x93, 0x92, 0x3c, 0x65,
	0x86, 0xec, 0x40, 0x4b, 0x70, 0xbf, 0x39, 0x6c, 0x8e, 0xfa, 0x61, 0x4b, 0x70, 0x42, 0x60, 0x23,
	0x8e, 0x96, 0xe8, 0xb7, 0x2c, 0x62, 0xbf, 0xc9, 0x10, 0x3c, 0x8e, 0x9a, 0x29, 0x91, 0x18, 0x21,
	0x63, 0xbf, 0x6d, 0x43, 0xab, 0x10, 0xf1, 0xa1, 0x97, 0x08, 0x66, 0x52, 0x85, 0xfe, 0x86, 0x8d,
	0xba, 0x23, 0x39, 0x83, 0x7e, 0xa2, 0x04, 0xc3, 0x79, 0xaa, 0xb9, 0xdf, 0x19, 0x36, 0x47, 0xde,
	0x84, 0x8c, 0x57, 0x54, 0x8d, 0x3f, 0xca, 0x18, 0xb3, 0x70, 0xd3, 0x92, 0xae, 0x34, 0x27, 0x47,
	0x00, 0x2c, 0x32, 0x78, 0x23, 0x95, 0x40, 0xed, 0x77, 0x87, 0xed, 0x51, 0x3f, 0x5c, 0x41, 0xe8,
	0x05, 0xec, 0x7d, 0x10, 0xda, 0x94, 0xfa, 0x75, 0x88, 0x3a, 0x91, 0xb1, 0x46, 0xf2, 0x1a, 0x36,
	0x93, 0x12, 0xf3, 0x9b, 0xc3, 0xf6, 0xc8, 0x9b, 0xec, 0x55, 0xea, 0x94, 0x17, 0xc2, 0x07, 0x16,
	0x3d, 0x81, 0xff, 0x02, 0x74, 0x89, 0x42, 0xbc, 0x4b, 0x51, 0xaf, 0xcd, 0x83, 0xbe, 0x82, 0xfd,
	0x4b, 0x8c, 0x14, 0xbb, 0x7d, 0x2c, 0x58, 0x10, 0xf7, 0xa0, 0x73, 0x97, 0xa2, 0xca, 0x4a, 0x6e,
	0x71, 0xa0, 0x17, 0x70, 0xf0, 0x94, 0x5e, 0xea, 0x1b, 0x43, 0x4f, 0xa1, 0x4e, 0x17, 0xff, 0x90,
	0xe7, 0x48, 0xf4, 0x33, 0x74, 0xec, 0x68, 0xc8, 0x09, 0x6c, 0xb3, 0x54, 0x29, 0x8c, 0x59, 0x36,
	0x67, 0x92, 0x63, 0x59, 0x70, 0xcb, 0x81, 0x33, 0xc9, 0x31, 0x57, 0x93, 0xc6, 0xc2, 0x68, 0xbb,
	0xb7, 0x76, 0x58, 0x1c, 0x72, 0x34, 0x8e, 0x62, 0xa9, 0xed, 0xca, 0x3a, 0x61, 0x71, 0xa0, 0x01,
	0x1c, 0x05, 0x68, 0x2e, 0xd3, 0x24, 0x91, 0xca, 0x20, 0x9f, 0x15, 0x79, 0x04, 0x3e, 0x6a, 0x7d,
	0x01, 0x3b, 0x95, 0x92, 0x85, 0xe4, 0x7e, 0xb8, 0xbd, 0x5a, 0x53, 0xd3, 0x2f, 0xf0, 0xff, 0xec,
	0x01, 0x88, 0xef, 0x51, 0x69, 0x21, 0x63, 0x37, 0x9f, 0x53, 0xd8, 0xf8, 0xa6, 0xe4, 0xd2, 0xaa,
	0xad, 0xdf, 0xb9, 0x8d, 0x93, 0x43, 0xe8, 0x19, 0x59, 0x34, 0x56, 0x78, 0xae, 0x6b, 0x64, 0x9e,
	0x9e, 0x8e, 0xa1, 0x3f, 0xe5, 0x2e, 0xdb, 0x31, 0x6c, 0x31, 0x19, 0x1b, 0xfc, 0x61, 0xe6, 0xdf,
	0x31, 0x73, 0x7a, 0xbc, 0x12, 0x7b, 0x8f, 0x99, 0xa6, 0x67, 0x00, 0x39, 0xbf, 0x6c, 0xe1, 0x18,
	0xda, 0x11, 0x77, 0xa3, 0xde, 0xad, 0x54, 0x9f, 0xf2, 0x30, 0x8f, 0xd1, 0x73, 0x68, 0x4d, 0x79,
	0x9e, 0x59, 0x21, 0x17, 0x0a, 0x99, 0x99, 0xa7, 0x6a, 0x51, 0x4e, 0xd7, 0x73, 0xd8, 0x95, 0x5a,
	0xe4, 0x6f, 0x22, 0xaf, 0xe2, 0xde, 0x44, 0xfe, 0x3d, 0xf9, 0xd9, 0x82, 0xfd, 0x72, 0x67, 0xb3,
	0xc8, 0x44, 0x0b, 0x79, 0x73, 0x89, 0xea, 0x5e, 0x30, 0x24, 0x01, 0x6c, 0xad, 0x1a, 0x94, 0x54,
	0x5b, 0xb7, 0x2f, 0x70, 0x70, 0x5c, 0xc1, 0xea, 0xfc, 0x4c, 0x1b, 0xe4, 0x2d, 0xc0, 0xa3, 0x3f,
	0xc9, 0x51, 0xe5, 0xca, 0x9a, 0x71, 0x07, 0xb5, 0x76, 0xa2, 0x0d, 0x72, 0x0d, 0x3b, 0x55, 0x47,
	0x12, 0x5a, 0x61, 0xd6, 0xba, 0x7b, 0x70, 0xf2, 0x2c, 0xc7, 0x49, 0x9c, 0xfc, 0x6a, 0xc2, 0xae,
	0xb3, 0x80, 0xeb, 0xff, 0x1a, 0x0e, 0xea, 0xed, 0x55, 0x3b, 0x89, 0x97, 0x4f, 0xdb, 0x7a, 0xc6,
	0x97, 0xb4, 0x41, 0x02, 0xe8, 0x15, 0x56, 0x33, 0xe4, 0xb4, 0x72, 0xf3, 0xaf, 0x46, 0x1c, 0xd4,
	0x58, 0x8f, 0x36, 0x26, 0x17, 0xb9, 0xbb, 0x9c, 0xe4, 0x73, 0xe8, 0x06, 0x68, 0xa6, 0x5c, 0x93,
	0x83, 0xa7, 0x4e, 0x29, 0x93, 0x1c, 0xae, 0xe1, 0x4e, 0xd2, 0xd7, 0xae, 0xfd, 0xd5, 0xbe, 0xf9,
	0x13, 0x00, 0x00, 0xff, 0xff, 0x4c, 0x3f, 0x46, 0x70, 0x78, 0x05, 0x00, 0x00,
}
